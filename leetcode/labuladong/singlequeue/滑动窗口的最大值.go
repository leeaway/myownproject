package singlequeue

/**
 * @author 2416144794@qq.com
 * @date 2023/1/29 10:29
 */

//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
//
// 示例:
//
//
//输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
//输出: [3,3,5,5,6,7]
//解释:
//
//  滑动窗口的位置                最大值
//---------------               -----
//[1  3  -1] -3  5  3  6  7       3
// 1 [3  -1  -3] 5  3  6  7       3
// 1  3 [-1  -3  5] 3  6  7       5
// 1  3  -1 [-3  5  3] 6  7       5
// 1  3  -1  -3 [5  3  6] 7       6
// 1  3  -1  -3  5 [3  6  7]      7
//
//
//
// 提示：
//
// 你可以假设 k 总是有效的，在输入数组 不为空 的情况下，1 ≤ k ≤ nums.length。
//
// 注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/
//
// Related Topics 队列 滑动窗口 单调队列 堆（优先队列） 👍 522 👎 0

/*
	使用单调队列求解
	单调队列详看：https://zhuanlan.zhihu.com/p/346354943

	“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理

	形象地打个比方，上面的序列可以看成学校里各个年级LOL选手，数字越大代表能力越强。每个选手只能在大学四年间参赛，毕业了就没有机会了。那么，每一年的王牌选手都在哪个年级呢？

		一开始的时候，大三大四的学长都比较菜，大二的最强，而大一的等大二的毕业后还有机会上位，所以队列里有两个数。
		一年过去了，原本大一的成为大二，却发现新进校的新生非常强，自己再也没有机会成为最大值了，所以弹出队列。
		又过了一年，新入校的新生尽管能力只有1，但理论上只要后面的人比他还菜，还是可能成为区间最大值的，所以入队。
		终于，原本的王牌毕业了，后面的人以为熬出头了，谁知道这时一个巨佬级别的新生进入了集训队，这下其他所有人都没机会了。
		（这只是比方，现实中各位选手的实力是会增长的，不符合这个模型ovo）
		总之，观察就会发现，我们维护的这个队列总是单调递减的。如果维护区间最小值，那么维护的队列就是单调递增的。这就是为什么叫单调队列。


*/

func getMaxInSlidingWindow(nums []int, k int) []int {
	//这里存索引
	var que []int
	if k == 1 {
		return nums
	}
	n := len(nums)
	res := make([]int, n-k+1)
	index := 0
	for index < n {
		//窗口范围溢出了，移除左端的元素
		if len(que) > 0 && index-que[0] >= k {
			que = que[1:]
		}
		//从队尾开始遍历，若比当前元素小，则不可能成为区间的最大值，pop掉
		for len(que) > 0 && nums[que[len(que)-1]] < nums[index] {
			que = que[:len(que)-1]
		}
		//新生入队
		que = append(que, index)
		//记录结果
		if index >= k-1 {
			res[index-k+1] = nums[que[0]]
		}
		index++
	}
	return res
}
